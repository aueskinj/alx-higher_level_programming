<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bezier Curve from Uploaded Mouse Data</title>
    <style>
        body { text-align: center; font-family: Arial, sans-serif; }
        canvas { border: 2px solid black; margin-top: 10px; display: block; margin-left: auto; margin-right: auto; }
        input, button { padding: 10px; margin-top: 10px; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>

    <h2>Bezier Curve from Uploaded Mouse Data</h2>
    <input type="file" id="fileInput" accept=".json">
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');

        let mouseData = []; // Stores uploaded mouse movement data

        // Moving Average Smoothing
        function movingAverageSmoothing(points, windowSize = 5) {
            let smoothedPoints = [];
            for (let i = 0; i < points.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                for (let j = Math.max(0, i - Math.floor(windowSize / 2)); j < Math.min(points.length, i + Math.floor(windowSize / 2)); j++) {
                    sumX += points[j].x;
                    sumY += points[j].y;
                    count++;
                }
                smoothedPoints.push({ x: sumX / count, y: sumY / count });
            }
            return smoothedPoints;
        }

        // Ramer-Douglas-Peucker Algorithm
        function ramerDouglasPeucker(points, epsilon) {
            if (points.length < 3) return points;
            let maxDist = 0, index = 0;
            for (let i = 1; i < points.length - 1; i++) {
                let dist = perpendicularDistance(points[i], points[0], points[points.length - 1]);
                if (dist > maxDist) {
                    maxDist = dist;
                    index = i;
                }
            }
            if (maxDist > epsilon) {
                let left = ramerDouglasPeucker(points.slice(0, index + 1), epsilon);
                let right = ramerDouglasPeucker(points.slice(index), epsilon);
                return left.slice(0, left.length - 1).concat(right);
            } else {
                return [points[0], points[points.length - 1]];
            }
        }

        function perpendicularDistance(point, lineStart, lineEnd) {
            let num = Math.abs((lineEnd.y - lineStart.y) * point.x - (lineEnd.x - lineStart.x) * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);
            let den = Math.sqrt(Math.pow(lineEnd.y - lineStart.y, 2) + Math.pow(lineEnd.x - lineStart.x, 2));
            return num / den;
        }

        // De Casteljau’s Algorithm for Bezier curve computation
        function deCasteljau(points, t) {
            while (points.length > 1) {
                let newPoints = [];
                for (let i = 0; i < points.length - 1; i++) {
                    let x = (1 - t) * points[i].x + t * points[i + 1].x;
                    let y = (1 - t) * points[i].y + t * points[i + 1].y;
                    newPoints.push({ x, y });
                }
                points = newPoints;
            }
            return points[0];
        }

        // Draw Bezier curve
        function drawBezierCurve(points) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (points.length < 2) {
                alert("Not enough points to generate a curve!");
                return;
            }

            // Draw control points
            ctx.fillStyle = "red";
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw control polygon
            ctx.strokeStyle = "brown";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();

            // Draw Bezier curve using De Casteljau’s algorithm
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                let point = deCasteljau([...points], t);
                if (t === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            }
            ctx.stroke();
        }

        // Handle file upload and parse JSON data
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let jsonData = JSON.parse(e.target.result);
                    mouseData = jsonData.map(entry => ({ x: entry.x, y: entry.y }));
                    let smoothed = movingAverageSmoothing(mouseData, 5);
                    let reduced = ramerDouglasPeucker(smoothed, 2);
                    drawBezierCurve(reduced);
                } catch (error) {
                    alert("Invalid JSON file format!");
                    console.error(error);
                }
            };
            reader.readAsText(file);
        });
    </script>

</body>
</html>
